Metalink:  443746.1

Applies to: 
Oracle Server Enterprise Edition - Version: 11.1.0.6 to 11.1.0.8
Information in this document applies to any platform.
Oracle Server - Enterprise Edition - Version: 11.1.0.6 
Purpose
The main goal of this document is to discuss Automatic Memory Management(AMM) features introduced with Oracle11g and how to enable it.

Scope and Application
All the DBAs and users concerned with Database Administration activities.

Automatic Memory Management(AMM) on 11g


Introduction to Database Memory Components

The basic memory structures associated with Oracle Database include:

 - System Global Area (SGA)

The SGA is a group of shared memory structures, known as SGA components, that contain data and control information for one Oracle Database instance.
The SGA is shared by all server and background processes. 

 - Program Global Area (PGA)

A PGA is a memory region that contains data and control information for a server process. It is nonshared memory created by Oracle Database when
a server process is started. Access to the PGA is exclusive to the server process. There is one PGA for each server process. Background processes also
allocate their own PGAs. The total PGA memory allocated for all background and server processes attached to an Oracle Database instance is referred to as
the total instance PGA memory, and the collection of all individual PGAs is referred to as the total instance PGA, or just instance PGA.

It contains global variables and data structures and control information for a server process. example of such information is the runtime area of a cursor. 
Each time a cursor is executed, a new runtime area is created for that cursor in the PGA memory region of the server process executing that cursor.

The performance of complex long running queries, typical in a DSS environment, depend to a large extent on the memory available in the Program Global Area
(PGA) which is also called work area.

Below figure illustrates the relationships among these memory structures

Evolution of Memory Management Features
Memory management has evolved with each database release 

Oracle 9i

Beginning with Oracle9i, the dynamic SGA infrastructure allowed for the sizing of the Buffer Cache, Shared Pool and the Large Pool without having
to shutdown the database. Key features being

Dynamic Memory resizing 
DB_CACHE_SIZE instead of DB_BLOCK_BUFFERS 
DB_nK_CACHE_SIZE for multiple block sizes 
PGA_AGGREGATE_TARGET Introduction of Automatic PGA Memory management

Oracle Database 10g
  
Automatic Shared Memory Management (ASMM) was introduced in 10g. You enable the automatic shared memory management feature by setting the SGA_TARGET
parameter to a non-zero value.

Oracle Database 11g

Automatic Memory Management is being introduced in 11g. This enables automatic tuning of PGA and SGA with use of two new parameters named
MEMORY_MAX_TARGET and MEMORY_TARGET. 

Oracle Database 11g supports various memory management methods, which are chosen by initialization parameter settings.
Oracle recommends that you enable the automatic memory management method.


Automatic Memory Management  -  For Both the SGA and Instance PGA 
Automatic Shared Memory Management  -  For the SGA 
Manual Shared Memory Management  -  For the SGA 
Automatic PGA Memory Management  -  For the Instance PGA 
Manual PGA Memory Management  -  For the Instance PGA 
1.Automatic Memory Management  -  For Both the SGA and Instance PGA
Beginning with Oracle Database 11g, Oracle Database can manage the SGA memory and instance PGA memory completely automatically. 
You designate only the total memory size to be used by the instance, and Oracle Database dynamically exchanges memory between the SGA and the
instance PGA as needed to meet processing demands. This capability is referred to as automatic memory management. With this memory management method, 
the database also dynamically tunes the sizes of the individual SGA components and the sizes of the individual PGAs.

To achieve this, two new parameters have been introduced named MEMORY_MAX_TARGET and MEMORY_TARGET. To do so (on most platforms),
you set only a target memory size initialization parameter (MEMORY_TARGET) and optionally a maximum memory size initialization parameter 
(MEMORY_MAX_TARGET).

Switching to Automatic Memory Management

1)Check the current values configured for SGA_TARGET and PGA_AGGREGATE_TARGET.

SQL>SHOW PARAMETER TARGET
NAME TYPE VALUE
------------------------------ ----------- ----------------
archive_lag_target integer 0
db_flashback_retention_target integer 1440
fast_start_io_target integer 0
fast_start_mttr_target integer 0
memory_max_target big integer 0
memory_target big integer 0
pga_aggregate_target big integer 200M
sga_target big integer 500M
Add the values of pga_aggregate_target and sga_target. In our case it would sum to 700 M

2)Decide on a maximum amount of memory that you would want to allocate to the database which will determine the maximum value for the sum of the
 SGA and instance PGA sizes. In our case we decide to set to 808M

3)Change the parameter in initialization parameter file. 

Using Spfile
========

SQL>ALTER SYSTEM SET MEMORY_MAX_TARGET = 808M SCOPE = SPFILE;
SQL>ALTER SYSTEM SET MEMORY_TARGET = 808M SCOPE = SPFILE;
SQL>ALTER SYSTEM SET SGA_TARGET =0 SCOPE = SPFILE;
SQL>ALTER SYSTEM SET PGA_AGGREGATE_TARGET = 0 SCOPE = SPFILE;

Using Pfile
=======
If you have started the instance with Pfile, then edit the pfile and set the parameters manually


MEMORY_MAX_TARGET = 1000M
MEMORY_TARGET = 1000M
SGA_TARGET =0
PGA_AGGREGATE_TARGET = 0

In case you do not specify any value for MEMORY_MAX_TARGET and only use MEMORY_TARGET then database automatically sets MEMORY_MAX_TARGET
to the value of MEMORY_TARGET. 

If you omit the line for MEMORY_TARGET and include a value for MEMORY_MAX_TARGET, the MEMORY_TARGET parameter defaults to zero.
After startup, you can then dynamically change MEMORY_TARGET to a non-zero value, provided that it does not exceed the value of MEMORY_MAX_TARGET.


MEMORY_MAX_TARGET is a static parameter i.e it cannot be changed Dynamically and Instance has to be bounced for modifying the value.
So ensure that you have set it to appropriate value.

4)Shutdown and startup the database

SQL> shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup mount
ORACLE instance started.

Total System Global Area  845348864 bytes
Fixed Size                  1303188 bytes
Variable Size             469765484 bytes
Database Buffers          369098752 bytes
Redo Buffers                5181440 bytes
SQL> show parameter target

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
archive_lag_target                   integer     0
db_flashback_retention_target        integer     1440
fast_start_io_target                 integer     0
fast_start_mttr_target               integer     0
memory_max_target                    big integer 808M
memory_target                        big integer 808M
pga_aggregate_target                 big integer 0
sga_target                           big integer 0


The preceding steps instruct you to set SGA_TARGET and PGA_AGGREGATE_TARGET to zero so that the sizes of the SGA and instance PGA are tuned up and down
as required, without restrictions. You can omit the statements that set these parameter values to zero and leave either or both of the values as
positive numbers. In this case, the values act as minimum values for the sizes of the SGA or instance PGA.


Monitoring and Tuning Automatic Memory Management

The dynamic performance view V$MEMORY_DYNAMIC_COMPONENTS shows the current sizes of all dynamically tuned memory components, including the total
sizes of the SGA and instance PGA.
The view V$MEMORY_TARGET_ADVICE provides tuning advice for the MEMORY_TARGET initialization parameter.

SQL> select * from v$memory_target_advice order by memory_size;

If you want to exercise more direct control over the size of the SGA, you can disable automatic memory management and enable automatic shared
memory management.This feature was introduced in 10g with a parameter known as SGA_TARGET. When automatic SGA memory management is enabled, 
the sizes of the different SGA components are flexible and can adapt to the needs of current workload without requiring any additional configuration.

Please refer to following document for setting SGA_TARGET

Note 295626.1 - How To Use Automatic Shared Memory Management (ASMM) In Oracle10g

In case you have enabled Automatic Memory Management , then to switch to Automatic Shared Memory Management , please follow below procedure

SQL>Alter system set MEMORY_TARGET=0 scope=both;
SQL>Alter system set SGA_TARGET=500M scope=both;


3. Manual Shared Memory Management  -  For the SGA

If you want complete control of individual SGA component sizes, you can disable both automatic memory management and automatic shared memory 
management. In this mode, you need to set the sizes of several individual SGA components, thereby determining the overall SGA size. 
You then manually tune these individual SGA components on an ongoing basis.

In this case you set SGA_TARGET and MEMORY_TARGET to 0 and set value for other SGA components upto value of SGA_MAX_SIZE

Please refer to Note 148495.1 - Dynamic SGA


4. Automatic PGA Memory Management  -  For the Instance PGA

While using Automatic memory management , PGA memory is allocated based upon value of MEMORY_TARGET.
In case you  enable automatic shared memory management or manual shared memory management, you also implicitly enable automatic PGA memory management. 



Automatic/Manual PGA memory management is decided by  initialization parameter WORKAREA_SIZE_POLICY  which is a session- and system-level parameter
that can take only two values: MANUAL or AUTO. The default is AUTO. 


With automatic PGA memory management, you set a target size for the instance PGA by defining value for parameter named PGA_AGGREGATE_TARGET and sizing
of SQL work areas is automatic and all *_AREA_SIZE initialization parameters are ignored for these sessions. This feature is available from 9i.

At any given time, the total amount of PGA memory available to active work areas on the instance is automatically derived from the parameter
PGA_AGGREGATE_TARGET. This amount is set to the value of PGA_AGGREGATE_TARGET minus the PGA memory allocated for other purposes
(for example, session memory). The resulting PGA memory is then allotted to individual active work areas based on their specific memory requirements.

Please refer to following document for more details on Automatic PGA Memory Management

Note 223730.1 - Automatic PGA Memory Managment in 9i and 10g

5.Manual PGA Memory Management  -  For the Instance PGA

In case you wish to manually specify the maximum work area size for each type of SQL operator (such as sort or hash-join) then you can enable Manual
PGA Memory management.

Set WORKAREA_SIZE_POLICY value to MANUAL and also specify values for *_area_size such as SORT_AREA_SIZE, HASH_AREA_SIZE, BITMAP_MERGE_AREA_SIZE,
and CREATE_BITMAP_AREA_SIZE, etc. 


Although the Oracle Database 11g supports this manual PGA memory management method, Oracle strongly recommends that you leave automatic
PGA memory management enabled.

Table below summarizes the various memory management methods

The Automatic  Memory Management (AMM) feature uses background process named Memory Manager (MMAN). This process was introduced in 
10g which assisted in Automatic Shared Memory Management (ASMM) using SGA_TARGET. MMAN serves as the SGA Memory Broker and coordinates the sizing
of the memory components. The SGA Memory Broker keeps track of the sizes of the components and pending resize operations




***** Displays mememory resize history
select * from DBA_HIST_MEMORY_RESIZE_OPS (v$memory_resize_ops)

This is the parameter that I set to keep an eye on the db cache size.  You can check it by doing a 
 
select * from v$buffer_pool.  
 
CURRENT_SIZE is the size of the cache in MB.
I set a warning at 3500 and an alert at 3000. 
I think if we go much below 3000, we may see performance impacts so if we see it trending that way, 
I'll get Tony's OK to set the lower limit to try and keep it from going down further.



Hey Eugene,
   In order to maybe avoid anything like we've had on wkabprod,
 during the upgrade we might want to go ahead and set the shared_pool_size and db_cache_size parameters to a little less than what they are currently.  I've been reading on it some since these issues with automatic memory management, and that's a recommended practice anyway (
 
You can check the current values by looking at V$SGA_DYNAMIC_COMPONENTS


 
I checked them and for DR02 we'd want to do:
 
alter system set shared_pool_size=700M scope=both;
alter system set db_cache_size=4000M scope=both;
 
For DM02 db_cache_size is already set to 1G, so we'd want to do:
 
alter system set shared_pool_size=300M scope=both;

select * from v$sga_dynamic_components



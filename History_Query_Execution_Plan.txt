Sometimes you will receive complains from users that something that has been running ok for ages on a production server, suddenly is running very very slowly. In 10g, AWR gives you the ability to go and check and possibly compare the execution path of a query at different times in the past.

select DBID, SQL_ID, SQL_TEXT from dba_hist_sqltext where sql_text like ‘%your query%’;

DBID      | SQL_ID      | SQL_TEXT | 

———-+————-+—————————+- 

1234567890|12345xxxxxxxx|UPDATE STAGING SET BLAH    | 



#####  We know that yesterday it was running fine, but today it’s not, and users have confirmed that data volumes are
###### identical between the two dates

select s.begin_interval_time, s.end_interval_time , q.snap_id, q.dbid, q.sql_id, q.plan_hash_value, q.optimizer_cost, q.optimizer_mode 
from dba_hist_sqlstat q, dba_hist_snapshot s 
where  q.sql_id = '42nmduqvvyu46'
and q.snap_id = s.snap_id
and s.begin_interval_time between sysdate-5 and sysdate 
order by s.snap_id desc;



####When you find this, take note of the PLAN_HASH_VALUE from the 2 different times that you want to compare

###Actually the 3 parameters that you need are:

###·         DBID 

###·         SQL_ID 

###·         PLAN_HASH_VALUE

 

###And to check the execution plan, run the following query:

 

select id, operation, options, object_name, cost 

from dba_hist_sql_plan 

where sql_id = '42nmduqvvyu46'

and plan_hash_value = '3204073102'

----

OPERATION
SELECT STATEMENT
SORT
HASH JOIN
TABLE ACCESS
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
TABLE ACCESS
INDEX
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS

---


###compare that with the second one

select id, operation, options, object_name, cost 

from dba_hist_sql_plan 

where sql_id = '42nmduqvvyu46'

and plan_hash_value = '1165987751'


---

OPERATION
SELECT STATEMENT
SORT
CONCATENATION
FILTER
NESTED LOOPS
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
FILTER
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
FILTER
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
TABLE ACCESS
INDEX
HASH JOIN
NESTED LOOPS
NESTED LOOPS
TABLE ACCESS
INDEX
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS
TABLE ACCESS
INDEX
INDEX
TABLE ACCESS
TABLE ACCESS


exec dbms_stats.gather_index_stats(ownname=>'WKAB10', indname=>'TASK_INSTANCE_IDX2', no_invalidate=>false, force=>true);

After that you still need to kill old sessions. Running longer > 300. After that all clear

************ FORUM *************

Recently there was a problem with a query, we came to know about the stale stats but since the application has a process to gather stats, we let app admin run the stats gathering process but still the performance was really bad for this SQL.

Later the vendor added a parameter to the stats gathering which enhanced the performance of the SQL.

That parameter was NO_INVALIDATE => FALSE.

After researching a bit, I got to know few things about this parameter - 

Before 10g when new statistics where generated all the exisiting SQL that referenced the tables that were changed was invalidated
With 10g, there is a new parameter "NO_INVALIDATE" added to the DBMS_STATS 
There are three options/values for this parameter -

1. FALSE - If set to false, it works just like it used to pre-10g. That means procedure invalidates the dependent cursors immediately if set to FALSE.
2. TRUE - All the SQL cursors will not get invalidated. Procedure does not invalidate the dependent cursors if set to TRUE
3. AUTO_INVALIDATE - This is default and this let Oracle decide when to invalidate dependent cursors. Cursors will remain active for 5 Hrs by default.

Question - How can changing the behaviour of gathering stats, so that the procedure invalidates the dependent SQL cursors immediately, helps in the performance of the query.

Answer: 
New statistics caused a new execution plan. However, the default behaviour would be to not invalidate the existing execution plan so your first attempt did not bring about an improvement because Oracle still used the old plan.
The NO_INVALIDATE set to FALSE caused Oracle to invalidate the plan and do a hard-parse to generate a new execution plan with the new statistics.


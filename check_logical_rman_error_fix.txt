Database: DR02

Level 0  Rman Backup with CHECK LOGICAL failed with following errors.


RMAN-00571: ===========================================================
RMAN-00569: =============== ERROR MESSAGE STACK FOLLOWS ===============
RMAN-00571: ===========================================================
RMAN-03002: failure of backup plus archivelog command at 09/06/2009 20:17:19

RMAN-03009: failure of backup command on ORA_SBT_TAPE_1 channel at 09/06/2009 19
:11:16
ORA-19566: exceeded limit of 0 corrupt blocks for file /u36/oracle/DR02/index/drwkab_index_08.dbf


=== Procedure to fix this issue===========
1) Use dbv to confirm the corruption
    dbv file=/u36/oracle/DR02/index/drwkab_index_08.dbf blocksize=4096

   Should show
Block Checking: DBA = 487031951, Block Type = KTB-managed data block   
data header at 0x1104ab05c                                             
kdbchk: row locked by non-existent transaction                         
        table=0   slot=38                                              
        lockid=1   ktbbhitc=2                                          
Page 492687 failed with check code 6101    

2) Get the info on the block
SQL> select dbms_utility.data_block_address_block(487031951) from dual;

DBMS_UTILITY.DATA_BLOCK_ADDRESS_BLOCK(487031951)
------------------------------------------------
                                          492687

SQL> select dbms_utility.data_block_address_file(487031951) from dual;

DBMS_UTILITY.DATA_BLOCK_ADDRESS_FILE(487031951)
-----------------------------------------------
                                            116
3) Find out if the block is allocated or free.  This will only work if it's free.

4) select * from dba_free_space where file_id=116 and 492687 between block_id and block_id+blocks-1;
    --> show show one row.  If so, the block is free.  If not, it's allocated to an object.

5) In SQLPlus do the following.  Note: 492687 is the corrupt block. And drwkab_data is the tablespace with the problem data file.

SQL> create table x (c1 number, c2 varchar2(4000)) tablespace 
SQL> drwkab_data;

Table created.

SQL> CREATE OR REPLACE TRIGGER corrupt_trigger
  2    AFTER INSERT ON x
  3    REFERENCING OLD AS p_old NEW AS new_p
  4    FOR EACH ROW
  5  DECLARE
  6    corrupt EXCEPTION;
  7  BEGIN
  8    IF (dbms_rowid.rowid_block_number(:new_p.rowid)=492687) then
  9       RAISE corrupt;
 10    END IF;
 11  EXCEPTION
 12    WHEN corrupt THEN
 13       RAISE_APPLICATION_ERROR(-20000, 'Corrupt block has been formatted');
 14  END;
 15  /

Trigger created.

6) Check free-space left in  the datafile
    select sum(bytes)/1024/1024 from dba_free_space where file_id=116;

7) Allocate enough space to cover the bad block.
    alter table x allocate extent (DATAFILE '/u36/oracle/DR02/index/drwkab_index_08.dbf' SIZE 1400M);

8) Insert rows into table (this should use the space you allocated to the table).  The trigger will fire when 
   the bad block is overwritten.
SQL> BEGIN
  2  FOR i IN 1..1000000000 LOOP
  3  INSERT INTO x select i, lpad('REFORMAT',3092, 'R') from dual;
  4  commit ;
  5  END LOOP;
  6  END;
  7  /
BEGIN
*
ERROR at line 1:
ORA-20000: Corrupt block has been formatted
ORA-06512: at "SYSTEM.CORRUPT_TRIGGER", line 9
ORA-04088: error during execution of trigger 'SYSTEM.CORRUPT_TRIGGER'
ORA-06512: at line 3

9) Flush the changed blocks out of memory
     alter system checkpoint;

10) Re-check w/ dbv as above.

11) Drop table x
***WKABPROD*****
****ORA-01555: snapshot too old: rollback segment number 3 with name "_SYSSMU3$" too small***
***See Mike Swafford response******************

Looks like the query ran for 12406 seconds before ending with the ORA-1555.
The undo retention period for WKABPROD is set for 3 (10800 sec) hours. 

That means that any query that runs for more than 3 hours may encounter the ORA-1555 
if it hits a block that it is unable to find undo for.

****>I have the 1st portion of the query in question...(from alert.log)

SELECT DISTINCT '5' AS KEY_FILE_REC_TYPE, '21' AS KEY_DETAIL_REC_TYPE, LPAD(C.CLAIM_ID,16,'0') AS KEY_PMEREF_NO , 
AC.CONTROL_NUMBER AS KEY_DSCLM_CTL_NO, LPAD(PK_AETNA_FEEDS.FN_RETURN_SSN(P.SSN), 9, 0) AS KEY_SUBS_ID_NO, NVL
(TO_CHAR(C.DISABILITY_DATE,'YYYY-MM-DD'),'0001-01-01') AS KEY_DSCLM_INCURRED_DT,
 RPAD(PK_AETNA_FEEDS.FN_CLAIMTY PE(C.PRODUCT_ID,C.STATUTORY_FLAG, C.VERSION_ID), 10, ' ') AS KEY_DSCLM_CLM_TY_CD,
 LPAD(BPR.PAY_REQ_ID, 12, 0) A S LPYMT_ID_NO, '0001-01-01' AS LPYMT_BNSCH_SRT_DT, '0001-01-01' AS LPYMT_BNSCH_CRE_DT, '00.00.00' AS LPYMT_BNSC H_CRE_TM, LPAD('99',4,0) AS LPYMT_RCPNT_ID, LPAD(PS_PAY.PAYCHECK_NBR,11,0) AS LPYMT_DRAFT_NO, (NVL(TO_CHAR(PS_K
NS.CHECK_DT,'YYYY-MM-DD'),'0001-01-01')) AS LPYMT_ISSUED_DT, CASE WHEN PS_PAY.NET_PAY 
IS NULL 
THEN '0000000' EL SE
LPAD(REPLACE(PK_AETNA_FEEDS.FN_DECODE_PMT(SUBSTR(TO_CHAR(ROUND(PS_PAY.NET_PAY*100,0)),1,7)),'-',''),7,'0') E ND
 AS LPYMT_AMT, DECODE(BPR.EFF_STATUS, 'M', '1', 'V', '2') AS LPYMT_DISP_CD, LPAD(PK_AETNA_FEEDS.FN_PAYMENTORI
 GIN_CD(BPR.IMMEDIATE_PAY,

I don't have the full query, so I can't tell for sure if the query had a poor query plan or 
if the client-side was just slow fetching data back.

Here is full query (received from Developer)


                                SELECT DISTINCT '5' as KEY_FILE_REC_TYPE,
                           '21' as KEY_DETAIL_REC_TYPE,
                           lpad(c.claim_id,16,'0')  as KEY_PMEREF_NO,
                           ac.CONTROL_NUMBER as KEY_DSCLM_CTL_NO,
                           lpad(PK_AETNA_FEEDS.fn_return_SSN(p.SSN), 9, 0) as KEY_SUBS_ID_NO,
                           nvl(TO_CHAR(c.DISABILITY_DATE,'YYYY-MM-DD'),'0001-01-01') as KEY_DSCLM_INCURRED_DT,
                           rpad(PK_AETNA_FEEDS.fn_claimtype(c.PRODUCT_ID,c.STATUTORY_FLAG, c.VERSION_ID), 10, ' ') as KEY_DSCLM_CLM_TY_CD,
                           lpad(bpr.PAY_REQ_ID, 12, 0) as LPYMT_ID_NO,
                           '0001-01-01' as LPYMT_BNSCH_SRT_DT,
                           '0001-01-01' as LPYMT_BNSCH_CRE_DT,
                           '00.00.00' as LPYMT_BNSCH_CRE_TM,
                           lpad('99',4,0) as LPYMT_RCPNT_ID,
                           lpad(ps_pay.paycheck_nbr,11,0) as LPYMT_DRAFT_NO,
                           (nvl(TO_CHAR(ps_kns.check_dt,'YYYY-MM-DD'),'0001-01-01')) as LPYMT_ISSUED_DT,
                           case when ps_pay.net_pay is null
                                    then '0000000'
                                    else lpad(replace(PK_AETNA_FEEDS.fn_decode_pmt(substr(to_char(round(ps_pay.net_pay*100,0)),1,7)),'-',''),7,'0')
                                    end
                           as LPYMT_AMT,
                           decode(bpr.EFF_STATUS, 'M', '1', 'V', '2') as LPYMT_DISP_CD,
                           lpad(PK_AETNA_FEEDS.fn_paymentorigin_cd(bpr.IMMEDIATE_PAY,ps_pay.paycheck_option, c.claim_id, bpr.pay_req_id ) ,1,' ') as LPYMT_ORGN_CD,
                           lpad(PK_AETNA_FEEDS.fn_paymentreason_cd(bpr.PAY_REQ_ID,c.BENEFIT_BEGIN_DATE, c.BENEFIT_THRU_DATE , c.CLAIM_ID,ps_kns.check_dt,p.SSN),1,' ') as LPYMT_REASON_CD,
                          (select lpad(replace(round(nvl(sum(tax_cur), 0)*100, 0), '-', ''), 7, 0) from s_ps_pay_tax a,  s_ps_kns_pay_check b
                                          where(a.company = b.company)
                                          and a.paygroup = b.paygroup
                                          and a.pay_end_dt = b.pay_end_dt
                                          and a.off_cycle = b.off_cycle
                                          and a.page_num = b.page_num
                                          and a.line_num = b.line_num
                                          and a.sepchk = b.sepchk
                                          and a.tax_class = 'H'
                                          and a.state = '$U'
                                          and b.kns_claim_no = to_char(c.CLAIM_ID)
                                          and b.kns_eob_no = ps_kns.kns_eob_no) as LPYMT_NET_FIT_AMT,
                           (select lpad(replace(round(nvl(sum(tax_cur), 0)*100, 0), '-', ''), 7, 0) from s_ps_pay_tax a, s_ps_kns_pay_check b
                                          where a.company = b.company
                                          and a.paygroup = b.paygroup
                                          and a.pay_end_dt = b.pay_end_dt
                                          and a.off_cycle = b.off_cycle
                                          and a.page_num = b.page_num
                                          and a.line_num = b.line_num
                                          and a.sepchk = b.sepchk
                                          and a.tax_class in ('D','F')
                                          and b.kns_claim_no = to_char(c.CLAIM_ID)
                                          and b.kns_eob_no = ps_kns.kns_eob_no) as LPYMT_NET_FICA_AMT,
                                (select lpad(replace(round(nvl(sum(tax_cur), 0)* 100, 0), '-', ''), 7, 0) from s_ps_pay_tax a, s_ps_kns_pay_check b
                                          where(a.company = b.company)
                                          and a.paygroup = b.paygroup
                                          and a.pay_end_dt = b.pay_end_dt
                                          and a.off_cycle = b.off_cycle
                                          and a.page_num = b.page_num
                                          and a.line_num = b.line_num
                                          and a.sepchk = b.sepchk
                                          and a.tax_class = 'H'
                                          and a.state <> '$U'
                                          and b.kns_claim_no = to_char(c.CLAIM_ID)
                                          and b.kns_eob_no = ps_kns.kns_eob_no) as LPYMT_NET_SIT_AMT,
                                (select lpad(replace(round(nvl(sum(tax_cur), 0)* 100, 0), '-', ''), 7, 0) from s_ps_pay_tax a, s_ps_kns_pay_check b
                                          where(a.company = b.company)
                                          and a.paygroup = b.paygroup
                                          and a.pay_end_dt = b.pay_end_dt
                                          and a.off_cycle = b.off_cycle
                                          and a.page_num = b.page_num
                                          and a.line_num = b.line_num
                                          and a.tax_class = 'H'
                                          and a.locality not in ('', ' ')
                                          and b.kns_claim_no = to_char(c.CLAIM_ID)
                                          and b.kns_eob_no = ps_kns.kns_eob_no) as LPYMT_NET_LIT_AMT,
                           nvl(TO_CHAR(bpr.PAY_FROM_DT,'YYYY-MM-DD'),'0001-01-01') as LPYMT_FROM_DT,
                           nvl(TO_CHAR(bpr.PAY_THROUGH_DT,'YYYY-MM-DD'),'0001-01-01') as LPYMT_THRU_DT,
                           nvl(TO_CHAR(bpr.STATUS_DT_TIME,'YYYY-MM-DD'),'0001-01-01') as LPYMT_LAST_UPDT_DT,
                           nvl(TO_CHAR(bpr.STATUS_DT_TIME,'HH.MI.SS'),'00.00.00') as LPYMT_LAST_UPDT_TM,
                           rpad(' ',7,' ') as LPYMT_FILLER,
                           to_number(case when round(ps_pay.net_pay,2) < 0
                                                 then (case when round(ps_pay.net_pay,2) < -999.99
                                                                then '-'||substr(to_char(replace(round(ps_pay.net_pay*100,0),'-','')),1,6)
                                                                        else '-'||lpad(substr(to_char(replace(round(ps_pay.net_pay*100,0),'-','')),1,6),6,'0')
                                                                        end
                                                          )
                                                 else lpad(substr(to_char(round(ps_pay.net_pay*100,0)),1,7),7,'0')
                                                 end
                                                )
                           as LPYMT_AMT_NUM
                FROM s_person p,
                         s_employee e,
                         s_beneng_payment_rqst bpr,
                         s_account_structure ac,
                         s_ps_pay_check ps_pay,
                         s_ps_kns_pay_check ps_kns,
                         s_dis_plan_version pv,
                         s_dis_plan pl,
                         (select cl.* from s_dis_claim cl, s_dis_rtw r where
                         cl.DISABILITY_DATE >= to_date(i_StartDate,'MM-DD-YYYY HH-MI-SS AM')
                         and cl.claim_id = r.claim_id
                         and cl.ACCOUNT_STRUCTURE_ID is not null
                         and cl.product_id < 6005
                         and cl.version_id not in (23293)
                         and not exists (select 1 from wkab10.vw_wkab_dup_claims v where cl.claim_id = v.claim_id)
                         AND
                         ((cl.claim_start_date >= to_date(i_StartDate, 'mm-dd-yyyy')
                          and cl.CLAIM_STATUS_ID = 32002)
                         OR
                         (cl.claim_status_id = 32003 and
                         r.RTW_STATUS_ID in (42003, 42004) and
                         (r.rtw_id = (PK_DIS_RTW.fn_get_active_rtw_id(cl.claim_id)))))) c
                WHERE p.PERSON_ID = e.PERSON_ID
                AND e.EMPLOYEE_ID = c.EMPLOYEE_ID
                AND PK_AETNA_FEEDS.fn_return_SSN(p.ssn) > 0
                and PK_AETNA_FEEDS.fn_return_SSN(lpad(ac.CONTROL_NUMBER, 9, 0)) > 0
                AND to_char(c.CLAIM_ID)   = bpr.CLAIM_NO
                AND bpr.EFF_STATUS in ('M', 'V')
                AND c.ACCOUNT_STRUCTURE_ID = ac.ACCOUNT_STRUCTURE_ID
                --and not exists (select 1 from wkab10.vw_wkab_dup_claims v where c.claim_id = v.claim_id)
                and pv.version_id = c.version_id
                and pv.plan_id = pl.plan_id
                and ((pl.statutory_flag = 1 and pl.statutory_state_code <> 27000) or (pl.statutory_flag <> 1))
                and (pv.BENEFIT_IDENTIFICATION_CODE_ID is not null or pv.BENEFIT_IDENTIFICATION_CODE_ID > 0)
                AND ps_pay.company = ps_kns.company
                and ps_pay.paygroup = ps_kns.paygroup
                and ps_pay.pay_end_dt = ps_kns.pay_end_dt
                and ps_pay.off_cycle = ps_kns.off_cycle
                and ps_pay.page_num = ps_kns.page_num
                and ps_pay.line_num = ps_kns.line_num
                and ps_pay.sepchk = ps_kns.sepchk
                and ps_kns.kns_claim_no = to_char(c.CLAIM_ID)
                and ps_kns.kns_eob_no = to_char(bpr.PAY_REQ_ID)
                and ps_pay.paycheck_nbr > 0
                and ps_pay.net_pay > 0
                ;

DataExtractApp.exe calls the stored procedure pk_feeds.sp_IHD_Payment_Feed which
 has the sql statement in the previous email...







Well when I do a query plan, the cost isn't great,
but it's not too outrageous.  It does, though, do a lot of interaction through a link to the Peoplesoft database.
If I had to guess, I'd say the long run times are are probably related to the select-list sub-queries.  
Right now, for every row returned by the main query, it does 4 queries over to Peoplesoft to fetch column values. 
 
The options are:
 
1) Do something to address the query run time.  Right now at least 3 1/2 hours.
  I don't see a plan problem on the wkabprod side,
  but with the remote access to the Peoplesoft database mixed into the query, 
  I don't see the plans for the portions on the remote database. 
 
2) Increase the undo retention time on WKABPROD.  
   This is a production change, so you'll have to engage Justin Jaworski or Dave Capasso to help coordinate.
   We may also need to increase the size of the UNDO tablespace depending on how much we
   needed to increase the undo retention time.


***ACTION TAKEN**********>

ALTER SYSTEM SET undo_retention=18000 SCOPE=BOTH;


alter database datafile '/workability/wkabprod/oracle/oradata/undotbs01.dbf' auoextend off
**********************************************************************************************

Just want to follow up on ORA-01555 issues that we had yesterday and this morning again.

I know you made changes to UNDO_RETENTION last night. (bumped it up to 18000) 

So now they going to have look into query itself?

Or you still planning to bump this parameter to bigger value?



Yes.  It hit 6.5 hours last night and bombed.  They are looking at workarounds right now.
They found that the extract query runs pretty quickly for 1-month at a time, 
so they are going to piece-meal the feed for this month and try working on a better fix for next month.

Mike



***************************ORA-01555: snapshot too old: rollback segment number 10 with name "R10" too small**************************

***********************************DR02*********************************************************************************************

Hi,
 
The failure happened yesterday also.After 3rd time resubmit it ran fine. 
I suspect that there are some other process which update/modify people soft db data during everyday early 
morning ( say up to 2 AM) ..Can you please look at this Fatal message and other processes related with people 
soft database especially for this extract query.??  and let us know what is happening behind at the database level.


There are a couple of things I can try to start with. 
 One is to increase the OPTIMAL size of the rollback segments.
 One of the reasons you might be getting this is that the rollback segments are shrinking back to optimal during the run and causing you to 
loose some rollback information you need. 
The other thing we could do is decrease the run time of the query.  
You might be able to do that by adding an index on ps_kns_ovpd_bal(asofdate). 
That might or might not improve the actual run-time of the query much since much of that time may be what you do with a row when you fetch it.

 
Well, it's a kind of resource contention. 

It's that this query is unable to maintain a read-consistent view of the data for the full time the query ran.  
There are several reasons it can happen, but the solution is either to reduce the run time of the query
(so that it doesn't have to maintain the consistent images in the rollback segments for so long) or to increase the amount
of time it maintains the consistent images (that was the goal with increasing optimal).
One other thing I didn't mention that we could try would be changing the run time of your job, so that it would occur
at a time that was quieter in terms of modifications to the tables involved.


***********DR02 8.1.7 **********************************************

ORA-01555: snapshot too old: rollback segment number 10 with name "R10" too small

Mike's response:

There are a couple of things I can try to start with. 
One is to increase the OPTIMAL size of the rollback segments. 
One of the reasons you might be getting this is that the rollback segments are shrinking back to optimal during the run and causing you to loose
some rollback information you need. 

The other thing we could do is decrease the run time of the query.  You might be able to do that by adding an index on ps_kns_ovpd_bal(asofdate). 
That might or might not improve the actual run-time of the query much since much of that time may be what you do with a row when you fetch it.



ORA-1650: unable to extend rollback segment R7 by 25600 in         tablespace RBS 
ORA-1650: unable to extend rollback segment RBSBIG by 51200 in         tablespace RBS 
ORA-1650: unable to extend rollback segment R7 by 25600 in         tablespace RBS 
ORA-1650: unable to extend rollback segment RBSBIG by 51200 in         tablespace RBS 


Sort of.  They were getting ORA-1555 errors then.
We increased the OPTIMAL size on the rollback segments then so that the inactive segments wouldn't shrink on them and get rid of needed rollback info. 

It has run fine since then as far as I know (no ORA-1555s).  This error means that they filled up the tablespace.  
So we could shrink the optimal (which might bring back the ORA-1555s) to free up some of the "idle" space used by
 the rollback segments or increase the size of the tablespace.

If that job completed around 10pm, it's possible that Oracle didn't have time to shrink the rollback segment back to normal size prior 
to the run of the Push2Datarep job since SMON only does it periodically.  

Perhaps what I'll do is add a little space to the RBS tablespace just in case and then we'll let it run tonight to see how it does.  Sound OK?


**************DR02 8.1.7 ************************************************************************************************************************

Subject: Alert error log for DR02

ORA-01595: error freeing extent (1) of rollback segment (0))
ORA-01594: attempt to wrap into rollback segment (0) extent (1) which is being freed Errors in file /u27/oracle/DR02/log/bdump/smon_454664_dr02.trc:
ORA-01595: error freeing extent (1) of rollback segment (0))
ORA-01594: attempt to wrap into rollback segment (0) extent (1) which is being freed Errors in file /u27/oracle/DR02/log/bdump/smon_454664_dr02.trc:

It just means that it got a little busy and SMON bumped into itself while trying to shrink a rollback segment.  
It's a non-fatal error.  The solution would be to increase optimal for the rollback segments so they don't shrink as often or 
to add some more so that SMON wasn't as likely to bump into itself.  
The other option is to upgrade to 10g and use system managed undo.  
That's my preferred option unless we see this frequently.

Mike


**********************************Monitor UNDO usage *********

!!! UNDO tablespace can go down in size, but use queryes below to determine real extent amount

************************************************************************************************************

You can also increase the size of UNDO_RETENTION parameter. To find the optimal value for your database's 
UNDO_RETENTION check your longest running query with the following query and increase the value 
of UNDO_RETENTION above that:-

SELECT max(maxquerylen) from v$undostat;

It will give you the max time taken by your longest running query. I hope this will work for you.

> So should we set the UNDO_RETENTION value to 237602 

That's 66 hours. (where did you get that number from?)

14400 is a little more reasonable (4 hours).

But remember that undo_retention is NOT a guarantee. 


3600 * 4 (hours) =value



select sum(bytes) from dba_free_space where tablespace_name='UNDOTBS1';
249823232

select sum(bytes) from dba_data_files where tablespace_name='UNDOTBS1';
12058624000

--Expired - The extent can be reused.

select sum(bytes) "EXPIRED BYTES" from dba_undo_extents where tablespace_name='UNDOTBS1'and status='EXPIRED';
2906128384
2932998144


-- Unexpired - There is no active transaction, but the extent is not available for reuse.
select sum(bytes) "UNEXPIRED BYTES" from dba_undo_extents where tablespace_name='UNDOTBS1'and status='UNEXPIRED';
8881635328

-- Active - There is an active transaction using this UNDO extent.
select sum(bytes) "EXPIRED BYTES" from dba_undo_extents where tablespace_name='UNDOTBS1'and status='ACTIVE';
4194304

Active - There is an active transaction using this UNDO extent.
Unexpired - There is no active transaction, but the extent is not available for reuse.
Expired - The extent can be reused.



**********************************************************************************
Read this to calculate UNDO TABLESPACE size: http://www.orafaq.com/node/1888


Sizing an UNDO tablespace requires three pieces of data. 

(UR) UNDO_RETENTION in seconds 
(UPS) Number of undo data blocks generated per second 
(DBS) Overhead varies based on extent and file size (db_block_size) 
UndoSpace = [UR * (UPS * DBS)] + (DBS * 24)

Two can be obtained from the initialization file: UNDO_RETENTION and DB_BLOCK_SIZE. 
The third piece of the formula requires a query against the database. The number of undo blocks generated per second can be acquired from V$UNDOSTAT. 

The following formula calculates the total number of blocks generated and divides it by the amount of time monitored, in seconds: 


SQL> SELECT (SUM(undoblks))/ SUM ((end_time - begin_time) * 86400)
FROM v$undostat;



SELECT (UR * (UPS * DBS)) + (DBS * 24) AS "Bytes" 
FROM (SELECT value AS UR FROM v$parameter WHERE name = 'undo_retention'), 
(SELECT (SUM(undoblks)/SUM(((end_time - begin_time)*86400))) AS UPS FROM v$undostat), 
(select block_size as DBS from dba_tablespaces where tablespace_name= 
(select upper(value) from v$parameter where name = 'undo_tablespace'));

SELECT (SUM(undoblks))/ SUM ((end_time - begin_time) * 86400) 
FROM v$undostat; 

SELECT TO_CHAR(BEGIN_TIME, 'MM/DD/YYYY HH24:MI:SS') BEGIN_TIME,
         TO_CHAR(END_TIME, 'MM/DD/YYYY HH24:MI:SS') END_TIME,
          UNDOBLKS, TXNCOUNT, MAXCONCURRENCY, NOSPACEERRCNT,SSOLDERRCNT
         FROM v$UNDOSTAT WHERE rownum <= 144;


 EXPSTEALCNT - when you start running short of space, this counter starts going up.  It means it's starting to steal unexpired blocks.
 EXPBLKRELCNT - This one going up is a good thing.  It means some blocks from old transactions were  expired so they were released

TUNED_UNDORETENTION - Oracle automatically starts tuning the undo retention downward when it starts running short of space.  
So when this starts to get pretty low it means Oracle is having to make the undo retention less and less in order to give you more space.
  Sorry one other
Berman, Eugene [8:46 AM]:
  ok. So should we use SUM for these 2 fields to get better picture
Swafford, Mike [8:46 AM]:
  UNXPSTEALCNT
  this one says that it's betting bad and having to steal unexpired blocks.
  so when this one starts showing something other than 0 you're under some pressure.

select BEGIN_TIME,EXPSTEALCNT as UP_IS_BAD,EXPBLKRELCNT as UP_IS_GOOD,
TUNED_UNDORETENTION, UNXPSTEALCNT as ZERO_IS_GOOD  FROM v$undostat

************************************************************************************************
Column Datatype Description 
BEGIN_TIME
 DATE
 Identifies the beginning of the time interval
 
END_TIME
 DATE
 Identifies the end of the time interval
 
UNDOTSN
 NUMBER
 Represents the last active undo tablespace in the duration of time. The tablespace ID of the active undo tablespace is returned in this column. If more than one undo tablespace was active in that period, the active undo tablespace that was active at the end of the period is reported.
 
UNDOBLKS
 NUMBER
 Represents the total number of undo blocks consumed. You can use this column to obtain the consumption rate of undo blocks, 
 and thereby estimate the size of the undo tablespace needed to handle the workload on your system.
 
TXNCOUNT
 NUMBER
 Identifies the total number of transactions executed within the period
 
MAXQUERYLEN
 NUMBER
 Identifies the length of the longest query (in number of seconds) executed in the instance during the period. You can use this statistic to estimate the proper setting of the UNDO_RETENTION initialization parameter.
 
MAXCONCURRENCY
 NUMBER
 Identifies the highest number of transactions executed concurrently within the period
 
UNXPSTEALCNT
 NUMBER
 Number of attempts to obtain undo space by stealing unexpired extents from other transactions
 
UNXPBLKRELCNT
 NUMBER
 Number of unexpired blocks removed from certain undo segments so they can be used by other transactions
 
UNXPBLKREUCNT
 NUMBER
 Number of unexpired undo blocks reused by transactions
 
EXPSTEALCNT
 NUMBER
 Number of attempts to steal expired undo blocks from other undo segments
 
EXPBLKRELCNT
 NUMBER
 Number of expired undo blocks stolen from other undo segments
 
EXPBLKREUCNT
 NUMBER
 Number of expired undo blocks reused within the same undo segments
 
SSOLDERRCNT
 NUMBER
 Identifies the number of times the error ORA-01555 occurred. You can use this statistic to decide whether or not the UNDO_RETENTION initialization parameter is set properly given the size of the undo tablespace. Increasing the value of UNDO_RETENTION can reduce the occurrence of this error.
 
NOSPACEERRCNT
 NUMBER
 Identifies the number of times space was requested in the undo tablespace and there was no free space available. That is, all of the space in the undo tablespace was in use by active transactions. The corrective action is to add more space to the undo tablespace.
 



         
         select count(*) from drwkab.WKAB_CLAIMANT_MV;
         
         
         --Actual Undo Size same as select sum(bytes) from dba_free_space where tablespace_name='UNDOTBS1';
         SELECT SUM(a.bytes) "UNDO_SIZE"
  FROM v$datafile a,
       v$tablespace b,
       dba_tablespaces c
 WHERE c.contents = 'UNDO'
   AND c.status = 'ONLINE'
   AND b.name = c.tablespace_name
   AND a.ts# = b.ts#;
   
   ---Optimal Undo Retention
   SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       ROUND((d.undo_size / (to_number(f.value) *
       g.undo_block_per_sec))) "OPTIMAL UNDO RETENTION [Sec]"
  FROM (
       SELECT SUM(a.bytes) undo_size
          FROM v$datafile a,
               v$tablespace b,
               dba_tablespaces c
         WHERE c.contents = 'UNDO'
           AND c.status = 'ONLINE'
           AND b.name = c.tablespace_name
           AND a.ts# = b.ts#
       ) d,
       v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
              undo_block_per_sec
         FROM v$undostat
       ) g
WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size';


--Calculate Needed UNDO Size for given Database Activity 
SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       (TO_NUMBER(e.value) * TO_NUMBER(f.value) *
       g.undo_block_per_sec) / (1024*1024) 
      "NEEDED UNDO SIZE [MByte]"
  FROM (
       SELECT SUM(a.bytes) undo_size
         FROM v$datafile a,
              v$tablespace b,
              dba_tablespaces c
        WHERE c.contents = 'UNDO'
          AND c.status = 'ONLINE'
          AND b.name = c.tablespace_name
          AND a.ts# = b.ts#
       ) d,
      v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
         undo_block_per_sec
         FROM v$undostat
       ) g
 WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size';



select tablespace_name,status,count(*)
from dba_undo_extents 
group by tablespace_name,status;

4
1593

1581
16


**************PUSH to DR failed in Aetnaprod*************************************

Initial Error on Aetnprod:

Error with Zeke job u0111007 running on UNIX Server aetnaprod at Fri Aug 28 00:27:42 EDT 2009: 
Connected.BEGINs_pk_push_2_datarep.WKAB_TASK_INSTANCE_MV;END;*ERRORatline1:ORA-30036:unabletoextendsegmentby16inundotablespace'UNDOTBS1'ORA-02063:
precedinglinefromDR02.WORLDORA-06512:at"WKAB10.PK_PUSH_2_DATAREP",line1107ORA-06512:atline1




got your email
  got the page from mission control. What was the issue?
Swafford, Mike [2:53 AM]:
  Sorry they got you out of bed.  
  They had a problem with their pk_push_2_datarep job.  
  It's a long story, but in the end.  I had to temporarily add undo space for them and bump up undo_retention on wkabprod
  I think they're running OK at the moment
  I'm monitoring it as we go.
Berman, Eugene [2:55 AM]:
  yea I see UNDO size is much bigger now. Ok. thanks
Swafford, Mike [2:56 AM]:
  There are 3 very large transactions hanging out there that are rolling back slowly that are leftovers from last night's job and from another thing they ran during the day.
  Like I said, it's a long story, but in the end, I think they're good now.  I had to get Bert and production services to OK bumping up the undo_retention on wkabprod to 4 hours. 
  THey're job failed last night because it ran over 3 hours (past the undo retention), but then the sessions stuck out there and didn't start rolling back until I killed them earlier this evening.  Now they are still rolling back and holding a ton of undo space, so tonight's job failed with not enough undo.  So I had to add more.
  that's it in a nutshell
Berman, Eugene [3:00 AM]:
  Ok got the story now. I will log off then for now
Swafford, Mike [3:00 AM]:
  Later.  Sorry they woke you up!
Berman, Eugene [3:00 AM]:
  np


alter tablespace untotbs01 add datafile '/u36/oracle/DR02/rbs/undo_20.dbf' size4G


alter tablespace undotbs1 add datafile '/u36/oracle/DR02/rbs/undo_20.dbf' size 4Gdbf' size 4G 

Completed: alter tablespace undotbs1 add datafile '/u36/oracle/DR02/rbs/undo_20.

Fri Aug 28 02:16:38 2009
alter tablespace undotbs1 add datafile '/u36/oracle/DR02/rbs/undo_21.dbf' size 8G



alter database datafile '/u36/oracle/DR02/rbs/undo_20.dbf' resize 8G

alter tablespace undotbs1 add datafile '/u36/oracle/DR02/rbs/undo_22.dbf' size 8G


alter tablespace undotbs1 add datafile '/u36/oracle/DR02/rbs/undo_23.dbf' size 8G


alter tablespace undotbs1 add datafile '/u36/oracle/DR02/rbs/undo_24.dbf' size 8G

alter database datafile '/u36/oracle/DR02/rbs/undo_20.dbf' resize 10G


On wkabprod UNDO_RETENTION was bumped up to 4 HOURS:

ALTER SYSTEM SET undo_retention=14400 SCOPE=BOTH;

and later on 

ALTER SYSTEM SET undo_retention=15500 SCOPE=BOTH;

ALTER SYSTEM SET undo_retention=20000 SCOPE=BOTH;



/u33/oracle/DR02/data


/u42/oracle/DR02/data/undo_32.dbf


*********** UNDO Issues when out of space error ***********

I got paged on this failed job due to out of space in UNDO TBS.
I added another 3GB and they restart the job again.  You are getting very tied on free space on that server.  
You need to get more DASD.

Yes.  It's a snapshot refresh that's been running since 3:15am.  From what I can tell, it's part of our problem with the overnight stuff.
When the pk_push_2_datarep runs long, it overlaps with this thing. 
Anyway, if I remember right, in the past, this thing used to do a truncate/direct-mode insert.
But it caused them issues because the table was empty when some of their feeds ran while it was going on.
So it was changed to be a delete/insert so that the data was available while the refresh was going on.


Overall, the it's really an issue with how the undo space gets broken up into the undo segments.  
If you look at this transaction, it has used about 12GB of undo.  Not huge, but it ends up tying up one of the undo segments. 
Overall, the problem just seems to be that we've got so many transactions running concurrently - several of them are large causing their associated 
undo segments to grow up towards 40 GB or so.  Then because other transactions come in and start using those undo segments,
they are tied up and don't get downsized.  The end result is that we end up needing more undo space than you'd expect.
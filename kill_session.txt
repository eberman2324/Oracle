grant alter system to system;
grant select on sys.v_$session to system;

create or replace procedure system.killsession (killsid IN VARCHAR2)
as
killserial   varchar2(20);

begin
killserial:='none';
select serial#
into killserial
from sys.v_$session
where sid = killsid
and username = 'WES';

execute immediate 'alter system kill session ''' || to_char (killsid) || ', ' || to_char (killserial) || '''' ;

EXCEPTION
WHEN NO_DATA_FOUND THEN
dbms_output.put_line('The SID ' || killsid || ' does not exist or cannot be killed');

end ;


Grant execute on the procedure to the user


For example, userxxx needs access to kill sessions so you would type the following:-


grant execute on system.killsession to userxxx;

The user needs to know the sid of the session being killed. For example, if a user needs to kill a session with a SID of 140 they would type:-


set serveroutput on
exec system.killsession ('140');

If they get the following error then there is no SID with a username of WES currently connected:-


The SID 140 does not exist or cannot be killed

  The various thoughts on allowing such a procedure centred on two strands, security and practical considerations


 


Security issues



Why do they need to kill jobs, what is causing the issue

What will developers want next

Sarbanes-Oxley considerations


Practical



How do you know the developer will kill one of his own processes and not a co-worker (think apps or sysadm job)

Can you use resource profiles to limit CPU usage

Use a standby to allow unrestricted resource usage


My view is that in certain development environments, for certain users it is reasonable to allow them to kill a process that is running rogue and as such I am happy to provide such a facility. This would not be allowed either unrestricted or in any sort of controlled environment such as production 


************************************************************************************************************************************


CREATE OR REPLACE EDITIONABLE PROCEDURE             AEDBA.LOCKUSER
as
 
  u_name varchar2(64);
  os_user varchar2(64);
  exeSql varchar2(200);
  exeSql2 varchar2(1200);
  procname varchar2(8) := 'LOCKUSER';
  smsg varchar2(5) := 'START';
  emsg varchar2(3) := 'END';
  my_code NUMBER;
  my_errm VARCHAR2(1000);
  run_cnt NUMBER;
  cursor csr is 
  
  select username
  from dba_users u
  where regexp_like (username, '[0123456789]') 
  and (username like 'A______' 
  or    username like 'N______'
  or    username like 'S______')
  and username not in ('S058102','S060331')
  and oracle_maintained = 'N'
  and account_status not like '%LOCKED%'
  and username not in
  (select grantee from dba_role_privs where granted_role = 'DBA')
  order by username;
  --BEGIN
  --  select count(*) into run_cnt from answers_lock_users_proc_status where run_status = 'Y';
  --  if run_cnt = 1 then
   --  BEGIN
   --   DBMS_OUTPUT.put_line(chr(10)||'Locking Procedure Has Already Been Run - Need To Run Unlock Procedure');
  --    RETURN;
  --  END;
  -- end if;
     select SYS_CONTEXT('USERENV', 'OS_USER') INTO os_user from dual;
     exeSql := 'delete from answers_lock_users';
     execute immediate exeSql; 
     commit;
     exeSql := 'insert into answers_upgrade_log values(:1,:2,:3,:4)';
     execute immediate exeSql using procname,smsg,os_user,sysdate; 
     commit;
    OPEN csr ;
      LOOP
       BEGIN
        FETCH csr INTO u_name;
        EXIT WHEN csr%NOTFOUND;
        DBMS_OUTPUT.put_line('Locking User '||u_name);
        exeSql := 'alter user '||u_name||' account lock';
        execute immediate exeSql;
        exeSql := 'insert into answers_lock_users values('||chr(39)||u_name||chr(39)||')';
        execute immediate exeSql;
        commit;
       EXCEPTION
          WHEN OTHERS THEN
           begin
             my_code := SQLCODE;
             my_errm := SQLERRM||' - Error Running : '||exeSql;
             exeSql2 := 'insert into answers_upgrade_log values(:1,:2,:3,:4)';
             execute immediate exeSql2 using procname,my_errm,os_user,sysdate;
             commit;
             DBMS_OUTPUT.put_line('Error Locking User : '||u_name);
           end;
       END;
    END LOOP;
    CLOSE csr;
    exeSql := 'update answers_lock_users_proc_status set run_status = '||chr(39)||'Y'||chr(39);
    execute immediate exeSql; 
    commit;
    exeSql := 'insert into answers_upgrade_log values(:1,:2,:3,:4)';
    execute immediate exeSql using procname,emsg,os_user,sysdate; 
    commit;
END LOCKUSER;
/



GRANT SELECT ON SYS.V_$SESSION TO AEDBA
/
GRANT SELECT ON SYS.DBA_USERS TO AEDBA
/
GRANT SELECT ON SYS.DBA_ROLE_PRIVS TO AEDBA
/
GRANT ALTER USER TO AEDBA
/

CREATE OR REPLACE EDITIONABLE PROCEDURE             AEDBA.KILL_SESSION
as

END KILL_SESSION;
/


https://oracleboss.wordpress.com/2018/02/17/procedure-to-kill-session/


grant alter system to aedba;
grant select on sys.v_$session to aedba;
grant select on sys.v_$process to aedba;

create or replace procedure AEDBA.KILL_SESSION 
as
statement varchar2(100);
begin
 select 'alter system kill session ''' || sid ||  ',' ||serial#|| ''';' from v$session where sql_id= '89m16v82twnax';
 execute immediate(statement);
 exception
 when no_data_found then
 raise_application_error(-20001, 'Session does not exist or SYS session / background process');
 when others then
 raise_application_error(-20002,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);
 end;
 /

create or replace procedure kill_session_v2(sqlid IN VARCHAR2 )
as
begin
    for x in ( select *
                 from v$session 
                where sql_id = sqlid )
    loop
        execute immediate 'alter system kill session ''' || 
                 p_sid || ',' || p_serial# || '''';
        dbms_output.put_line( 'Alter session done' );
    end loop;
end;
/



 CREATE OR REPLACE PROCEDURE aedba.kill_session (users IN VARCHAR2)
    AS
       stmt          VARCHAR (5000);
    
       CURSOR get_sessions
       IS
          SELECT s.sid sid, s.serial# ser
            FROM v$session s, v$process p
           WHERE s.username = users AND p.addr(+) = s.paddr;
    
    BEGIN
       FOR session_rec IN get_sessions
       LOOP
          BEGIN
             stmt :=  'ALTER SYSTEM KILL SESSION ''' || session_rec.sid || ',' || session_rec.ser || '''' || ' IMMEDIATE';
             --dbms_output.put_line(stmt);
             BEGIN
                EXECUTE IMMEDIATE stmt;
                EXCEPTION WHEN others THEN
              dbms_output.put_line('Error killing session: ' || stmt);
              dbms_output.put_line(SQLERRM);
             EXCEPTION
                WHEN OTHERS
                THEN
                   -- You probably need to log this error properly here.
                   -- I will just re-raise it.
                   CONTINUE;
             END;
          END;
       END LOOP;
    END;
    /

GRANT EXECUTE ON aedba.kill_session TO A605753;


************************************************************************************************************************
************************************************************************************************************************

CREATE TABLE AEDBA.KILL_SESSION_LOG
(
    USERNAME_WHO_KILLED     VARCHAR2(30)  NOT NULL,
    KILLED_SESSION_USERNAME VARCHAR2(30)  NOT NULL,
    KILLED_SESSION_SQLID    VARCHAR2(35)  NOT NULL,
    KILLED_SESSION_MACHINE  VARCHAR2(100) NOT NULL,
    KILLED_SESSION_DT       DATE          DEFAULT SYSDATE NOT NULL
)
ORGANIZATION HEAP
TABLESPACE AUDIT_SPACE
LOGGING
PCTFREE 10
PCTUSED 0
INITRANS 1
MAXTRANS 255
STORAGE(BUFFER_POOL DEFAULT)
NOPARALLEL
NOCACHE
NOROWDEPENDENCIES
NO INMEMORY
/


grant alter system to aedba;
grant select on sys.v_$session to aedba;
grant select on sys.v_$process to aedba;
grant select on sys.v_$sql to aedba;

CREATE OR REPLACE EDITIONABLE PROCEDURE                                                                                           AEDBA.KILL_SESSION_BY_SQLID(sqlid IN VARCHAR2)
    AS
  /* This Procedure will kill oracle session(s) by SQL ID
        User AEDBA Requires The Following Elevated Permissions
        grant alter system to aedba;
        grant select on sys.v_$session to aedba;
        grant select on sys.v_$process to aedba;
        Following table must be added under AEDBA as well as part of iinitial setup
        AEDBA.KILL_SESSION_LOG
        */
       stmt          VARCHAR (5000);
       exeSql        varchar2(2000);
       u_name        varchar2(64);
    
       CURSOR get_sessions
       IS
          SELECT s.sid sid, s.serial# ser, s.MACHINE mac, s.USERNAME usr
            FROM v$session s, v$process p
           WHERE s.sql_id = sqlid AND p.addr(+) = s.paddr;
    
    BEGIN
       FOR session_rec IN get_sessions
       LOOP
          BEGIN
             stmt :=  'ALTER SYSTEM KILL SESSION ''' || session_rec.sid || ',' || session_rec.ser || '''';
             dbms_output.put_line(stmt);
             BEGIN
                EXECUTE IMMEDIATE stmt;
                
                select SYS_CONTEXT('USERENV', 'SESSION_USER') INTO u_name from dual;
                exeSql := 'insert into AEDBA.KILL_SESSION_LOG values(:1,:2,:3,:4,:5)';
                execute immediate exeSql using u_name,session_rec.usr,sqlid,session_rec.mac,sysdate;
                commit;
                
                EXCEPTION WHEN others THEN
                   dbms_output.put_line('Error killing session: ' || SQLERRM);
                   dbms_output.put_line(SQLERRM);
             END;
          END;
       END LOOP;
     
    END;
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A593907
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A607796
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A616427
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A605753
/





set serveroutput on
exec aedba.kill_session_by_sqlid('4d5prv760rabb')

36161aw5qv50h


select * from AEDBA.KILL_SESSION_LOG ORDER BY 5 DESC

select c.hcc_id, cons.consltd_input_clm_type_txt, c.cvc_type_txt, c.OPS_NM, c.latest_type_nm, c.server_nm, c.ready_queue_nm, c.create_time_dts, c.last_tx_dt, c.cvc_context_id, c.latest_dsc, cons.spplr_id,
    c.parent_context_cvc_context_id, c.mutex_cond_tag_txt, c.last_operator_txt, c.addnl_txt, c.tag_txt, c.* 
from prod.cvc_instance_context c
    ,prod.consolidated_claim cons
    ,prod.supplier s
    ,prod.organization_information o
where 
      c.LAST_TX_DT >= to_date('2022-01-01 00:00:00','yyyy-mm-dd HH24:MI:SS')
  and c.LAST_TX_DT < to_date('2023-12-01 00:00:00','yyyy-mm-dd HH24:MI:SS')
  and c.state_txt = 'C'
  and c.cvc_type_txt = 'ClaimCVC'
  and c.ready_queue_nm = 'javax.jms.ReadyQueue'
  and c.server_nm in ('claimserver8','claimserver9','claimserver10','claimserver11','claimserver37','claimserver38','claimserver39')
  and cons.hcc_clm_nbr = c.hcc_id
  and s.spplr_id = cons.spplr_id
  and (s.endor_expire_dt is null or s.endor_expire_dt >= sysdate)
  and (s.ver_expire_dt is null or s.ver_expire_dt >= sysdate)
  and o.organization_info_id = s.organization_info_id 
  and o.ver_id = s.ver_id
  and cons.consltd_input_clm_type_txt='d'
order by c.ready_queue_nm, c.LAST_TX_DT desc, c.server_nm




## Good example/explanation when to close or not to close cursors
https://stackoverflow.com/questions/28330884/when-you-do-not-need-to-close-a-cursor-in-oracle


KILL_SESSION_BY_SQLID
KILL_SESSION_BY_SID
KILL_SESSION_BY_SQLID_AND_PHV (Plan hash value)



CREATE OR REPLACE EDITIONABLE PROCEDURE                                                                                           AEDBA.KILL_SESSION_BY_SID(sid IN VARCHAR2)
    AS
  /* This Procedure will kill oracle session(s) by SQL ID
        User AEDBA Requires The Following Elevated Permissions
        grant alter system to aedba;
        grant select on sys.v_$session to aedba;
        grant select on sys.v_$process to aedba;
        Following table must be added under AEDBA as well as part of iinitial setup
        AEDBA.KILL_SESSION_LOG
        */
       stmt          VARCHAR (5000);
       exeSql        varchar2(2000);
       u_name        varchar2(64);
    
       CURSOR get_sessions
       IS
          SELECT s.sid sid, s.serial# ser, s.MACHINE mac, s.USERNAME usr, s.sql_id as sqlid
            FROM v$session s, v$process p
           WHERE s.sid = sid AND p.addr(+) = s.paddr;
    
    BEGIN
       FOR session_rec IN get_sessions
       LOOP
          BEGIN
             stmt :=  'ALTER SYSTEM KILL SESSION ''' || sid || ',' || session_rec.ser || '''';
             dbms_output.put_line(stmt);
             BEGIN
                EXECUTE IMMEDIATE stmt;
                
                select SYS_CONTEXT('USERENV', 'SESSION_USER') INTO u_name from dual;
                exeSql := 'insert into AEDBA.KILL_SESSION_LOG values(:1,:2,:3,:4,:5)';
                execute immediate exeSql using u_name,session_rec.usr,session_rec.sqlid,session_rec.mac,sysdate;
                commit;
                
                EXCEPTION WHEN others THEN
                   dbms_output.put_line('Error killing session: ' || SQLERRM);
                   dbms_output.put_line(SQLERRM);
             END;
          END;
       END LOOP;
     
    END;
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A593907
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A607796
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A616427
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A605753
/



exec aedba.kill_session_by_sid('2010')





CREATE OR REPLACE EDITIONABLE PROCEDURE                                                                                           AEDBA.KILL_SESSION_BY_SQLID_AND_PHV(sqlid IN VARCHAR2, phv IN VARCHAR2)
    AS
  /* This Procedure will kill oracle session(s) by SQL ID
        User AEDBA Requires The Following Elevated Permissions
        grant alter system to aedba;
        grant select on sys.v_$session to aedba;
        grant select on sys.v_$process to aedba;
        grant select on sys.v_$sql to aedba;
        Following table must be added under AEDBA as well as part of iinitial setup
        AEDBA.KILL_SESSION_LOG
        */
       stmt          VARCHAR (5000);
       exeSql        varchar2(2000);
       u_name        varchar2(64);
    
       CURSOR get_sessions
       IS
        SELECT s.sid sid, s.serial# ser, s.MACHINE mac, s.USERNAME usr
           from v$session s
           join v$sql q ON s.sql_id = q.sql_id
           where s.sql_id = sqlid and q.plan_hash_value = phv and q.users_executing > 0;
    
    BEGIN
       FOR session_rec IN get_sessions
       LOOP
          BEGIN
             stmt :=  'ALTER SYSTEM KILL SESSION ''' || session_rec.sid || ',' || session_rec.ser || '''';
             dbms_output.put_line(stmt);
             BEGIN
                EXECUTE IMMEDIATE stmt;
                
                select SYS_CONTEXT('USERENV', 'SESSION_USER') INTO u_name from dual;
                exeSql := 'insert into AEDBA.KILL_SESSION_LOG values(:1,:2,:3,:4,:5)';
                execute immediate exeSql using u_name,session_rec.usr,sqlid,session_rec.mac,sysdate;
                commit;
                
                EXCEPTION WHEN others THEN
                   dbms_output.put_line('Error killing session: ' || SQLERRM);
                   dbms_output.put_line(SQLERRM);
             END;
          END;
       END LOOP;
     
    END;
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A593907
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A607796
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A616427
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A605753
/


exec aedba.kill_session_by_sqlid_and_phv('4d5prv760rabb','1474311377')


  SELECT s.sid sid, s.serial# ser, s.MACHINE mac, s.USERNAME usr
           from v$session s
           join v$sql q ON s.sql_id = q.sql_id
           where s.sql_id = sqlid and q.plan_hash_value = phv and q.users_executing > 0



RL!t3lm40UahNCZekMSFi5sV1DxAoj


*******************************************


GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID  TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A236120
/

GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A229515
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID  TO A229515
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A229515
/

GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A607483
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID  TO A607483
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A607483
/

GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A738300
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID  TO A738300
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A738300
/




****** LATEST PROD VERSIONS as of 6/20/2024 *******

CREATE OR REPLACE EDITIONABLE PROCEDURE                                                                                                 AEDBA.KILL_SESSION_BY_SQLID(sqlid IN VARCHAR2)
    AS
  /* This Procedure will kill oracle session(s) by SQL ID
        User AEDBA Requires The Following Elevated Permissions
        grant alter system to aedba;
        grant select on sys.v_$session to aedba;
        grant select on sys.v_$process to aedba;
        Following table must be added under AEDBA as well as part of iinitial setup
        AEDBA.KILL_SESSION_LOG
        */
       stmt          VARCHAR (5000);
       exeSql        varchar2(2000);
       u_name        varchar2(64);
    
       CURSOR get_sessions
       IS
          SELECT s.sid sid, s.serial# ser, s.MACHINE mac, s.USERNAME usr
            FROM v$session s, v$process p
           WHERE s.sql_id = sqlid AND p.addr(+) = s.paddr;
    
    BEGIN
       FOR session_rec IN get_sessions
       LOOP
          BEGIN
             stmt :=  'ALTER SYSTEM KILL SESSION ''' || session_rec.sid || ',' || session_rec.ser || '''';
             dbms_output.put_line(stmt);
             BEGIN
                EXECUTE IMMEDIATE stmt;
                
                select SYS_CONTEXT('USERENV', 'SESSION_USER') INTO u_name from dual;
                exeSql := 'insert into AEDBA.KILL_SESSION_LOG values(:1,:2,:3,:4,:5)';
                execute immediate exeSql using u_name,session_rec.usr,sqlid,session_rec.mac,sysdate;
                commit;
                
                EXCEPTION WHEN others THEN
                   dbms_output.put_line('Error killing session: ' || SQLERRM);
                   dbms_output.put_line(SQLERRM);
             END;
          END;
       END LOOP;
     
    END;
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A229515
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A738300
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID TO A607483
/


CREATE OR REPLACE EDITIONABLE PROCEDURE                                                                                                 AEDBA.KILL_SESSION_BY_SID(sid IN VARCHAR2)
    AS
  /* This Procedure will kill oracle session(s) by SQL ID
        User AEDBA Requires The Following Elevated Permissions
        grant alter system to aedba;
        grant select on sys.v_$session to aedba;
        grant select on sys.v_$process to aedba;
        Following table must be added under AEDBA as well as part of iinitial setup
        AEDBA.KILL_SESSION_LOG
        */
       stmt          VARCHAR (5000);
       exeSql        varchar2(2000);
       u_name        varchar2(64);
    
       CURSOR get_sessions
       IS
          SELECT s.sid sid, s.serial# ser, s.MACHINE mac, s.USERNAME usr, s.sql_id as sqlid
            FROM v$session s, v$process p
           WHERE s.sid = sid AND p.addr(+) = s.paddr;
    
    BEGIN
       FOR session_rec IN get_sessions
       LOOP
          BEGIN
             stmt :=  'ALTER SYSTEM KILL SESSION ''' || sid || ',' || session_rec.ser || '''';
             dbms_output.put_line(stmt);
             BEGIN
                EXECUTE IMMEDIATE stmt;
                
                select SYS_CONTEXT('USERENV', 'SESSION_USER') INTO u_name from dual;
                exeSql := 'insert into AEDBA.KILL_SESSION_LOG values(:1,:2,:3,:4,:5)';
                execute immediate exeSql using u_name,session_rec.usr,session_rec.sqlid,session_rec.mac,sysdate;
                commit;
                
                EXCEPTION WHEN others THEN
                   dbms_output.put_line('Error killing session: ' || SQLERRM);
                   dbms_output.put_line(SQLERRM);
             END;
          END;
       END LOOP;
     
    END;
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A229515
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A738300
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SID TO A607483
/

CREATE OR REPLACE EDITIONABLE PROCEDURE                                                                                                 AEDBA.KILL_SESSION_BY_SQLID_AND_PHV(sqlid IN VARCHAR2, phv IN VARCHAR2)
    AS
  /* This Procedure will kill oracle session(s) by SQL ID
        User AEDBA Requires The Following Elevated Permissions
        grant alter system to aedba;
        grant select on sys.v_$session to aedba;
        grant select on sys.v_$process to aedba;
        grant select on sys.v_$sql to aedba;
        Following table must be added under AEDBA as well as part of iinitial setup
        AEDBA.KILL_SESSION_LOG
        */
       stmt          VARCHAR (5000);
       exeSql        varchar2(2000);
       u_name        varchar2(64);
    
       CURSOR get_sessions
       IS
        SELECT s.sid sid, s.serial# ser, s.MACHINE mac, s.USERNAME usr
           from v$session s
           join v$sql q ON s.sql_id = q.sql_id
           where s.sql_id = sqlid and q.plan_hash_value = phv and q.users_executing > 0;
    
    BEGIN
       FOR session_rec IN get_sessions
       LOOP
          BEGIN
             stmt :=  'ALTER SYSTEM KILL SESSION ''' || session_rec.sid || ',' || session_rec.ser || '''';
             dbms_output.put_line(stmt);
             BEGIN
                EXECUTE IMMEDIATE stmt;
                
                select SYS_CONTEXT('USERENV', 'SESSION_USER') INTO u_name from dual;
                exeSql := 'insert into AEDBA.KILL_SESSION_LOG values(:1,:2,:3,:4,:5)';
                execute immediate exeSql using u_name,session_rec.usr,sqlid,session_rec.mac,sysdate;
                commit;
                
                EXCEPTION WHEN others THEN
                   dbms_output.put_line('Error killing session: ' || SQLERRM);
                   dbms_output.put_line(SQLERRM);
             END;
          END;
       END LOOP;
     
    END;
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A229515
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A236120
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A738300
/
GRANT EXECUTE ON AEDBA.KILL_SESSION_BY_SQLID_AND_PHV TO A607483
/





Got email that batchprinting.exe running slow. Not sure how this related to database. But it was reported 100% cpu utilization on Windows Server

Looked at WKABSTG1 database and found connection from this app. Was able to extract sql below. Based on execution plan it was doing full table scan.

SELECT DISTINCT S_REPORT_QUEUE.REPORT_BATCH_ID
FROM S_REPORT_QUEUE 
WHERE (S_REPORT_QUEUE.BATCH_DATE >= :B4 
AND S_REPORT_QUEUE.BATCH_DATE <= :B3 ) 
AND (( INSTR(:B2, TO_CHAR(COMPANY_ID)) > 0 
AND :B1 = 'F') 
OR (INSTR(:B2, TO_CHAR(COMPANY_ID)) = 0 
AND :B1 = 'N') 
OR :B1 = 'A')


Index below fixed speed up this query.



create index WKAB10.T_REPORT_QUEUE_IDX7 on WKAB10.T_REPORT_QUEUE(REPORT_BATCH_ID,BATCH_DATE,COMPANY_ID) tablespace wkab_index compute statistics;



!!!! Based on Mike's get_sql_by_hash script which is reads query run time execution. SQL above was alredy using different Index (which he created prior)


QUESTION: I was using Query Plan feature from DBArtizan and shows different result. Strange?

ANSWER: When you do an explain plan, it doesn't have any values to check the plan cost with so it "guesses". 
        When you actually run the SQL Oracle does bind variable peeking and uses actual values to look at the statistics and
        determine the plan.  So the run-time plan can be different than the explained plan.


So based on this I dropped index that I created (WKAB10.T_REPORT_QUEUE_IDX7) and now we will see if this going to bring problem back or not.
Initial problem was on Windows Server which was 100% CPU where  WkabBatchPrint.exe runs. SInce 100% was on Client side not on Oracle Database,
this could be not Oracle issue at all.

EXPLAIN PLAN Usage
http://www.oracle-base.com/articles/8i/ExplainPlanUsage.php#ExplainPlan


Plan Table
The explain plan process stores data in the PLAN_TABLE. This table can be located in the current 
schema or a shared schema and is created using in SQL*Plus as follows:

SQL> CONN sys/password AS SYSDBA
Connected
SQL> @$ORACLE_HOME/rdbms/admin/utlxplan.sql
SQL> GRANT ALL ON sys.plan_table TO public;
SQL> CREATE PUBLIC SYNONYM plan_table FOR sys.plan_table;

AUTOTRACE - The Easy Option?
Switching on the AUTOTRACE parameter in SQL*Plus causes an explain to be performed on every query.

SQL> SET AUTOTRACE ON
SQL> SELECT *
  2  FROM   emp e, dept d
  3  WHERE  e.deptno = d.deptno
  4  AND    e.ename  = 'SMITH';

     EMPNO ENAME      JOB              MGR HIREDATE         SAL       COMM
---------- ---------- --------- ---------- --------- ---------- ----------
    DEPTNO     DEPTNO DNAME          LOC
---------- ---------- -------------- -------------
      7369 SMITH      CLERK           7902 17-DEC-80        800
        20         20 RESEARCH       DALLAS



Execution Plan
----------------------------------------------------------
   0      SELECT STATEMENT Optimizer=CHOOSE
   1    0   NESTED LOOPS
   2    1     TABLE ACCESS (FULL) OF 'EMP'
   3    1     TABLE ACCESS (BY INDEX ROWID) OF 'DEPT'
   4    3       INDEX (UNIQUE SCAN) OF 'PK_DEPT' (UNIQUE)


or

set autotrace traceonly explain
select sysdate from dual;

This is a relatively easy way to get the execution plan but there is an issue.
 In order to get the execution plan the statement must be run to completion. 
If the query is particularly inefficient and/or returns many rows, this may take a considerable time. 
At first glance, using the TRACEONLY option of AUTOTRACE seems to remove this issue, 
but this option merely suppresses the output of the query data, it doesn't prevent the statement being run.
 As such, long running queries will still take a long time to complete, but they will not present their data.

The query takes the same time to return (about 10 seconds) whether the TRACEONLY option is used or not. If the TRACEONLY option prevented the query running, you would expect it to return instantly, like an EXPLAIN PLAN.

The solution to this is to use the TRACEONLY EXPLAIN option, which only performs the EXPLAIN PLAN, rather than running the statement.

EXPLAIN PLAN
The EXPLAIN PLAN method doesn't require the query to be run, greatly reducing the time it takes
 to get an execution plan for long-running queries compared to AUTOTRACE. First the query must be explained:

SQL> EXPLAIN PLAN FOR
  2  SELECT *
  3  FROM   emp e, dept d
  4  WHERE  e.deptno = d.deptno
  5  AND    e.ename  = 'SMITH';

Explained.

SQL>
Then the execution plan displayed:

SQL> @$ORACLE_HOME/rdbms/admin/utlxpls.sql

Plan Table
--------------------------------------------------------------------------------
| Operation                 |  Name    |  Rows | Bytes|  Cost  | Pstart| Pstop |
--------------------------------------------------------------------------------
| SELECT STATEMENT          |          |       |      |        |       |       |
|  NESTED LOOPS             |          |       |      |        |       |       |
|   TABLE ACCESS FULL       |EMP       |       |      |        |       |       |
|   TABLE ACCESS BY INDEX RO|DEPT      |       |      |        |       |       |
|    INDEX UNIQUE SCAN      |PK_DEPT   |       |      |        |       |       |
--------------------------------------------------------------------------------

8 rows selected.


Statement ID
If multiple people are accessing the same plan table, 
or you would like to keep a history of the execution plans you should use the STATEMENT_ID. T
his associates a user specified ID with each plan which can be used when retrieving the data.

SQL> EXPLAIN PLAN SET STATEMENT_ID = 'TIM' FOR
  2  SELECT *
  3  FROM   emp e, dept d
  4  WHERE  e.deptno = d.deptno
  5  AND    e.ename  = 'SMITH';

Explained.

SQL> @explain.sql TIM

PLAN                                   OBJECT_NAME     OBJECT_TYPE     BYTES  COST PARTITION_START PARTITION_STOP
-------------------------------------- --------------- --------------- ----- ----- --------------- ---------------
Select Statement                                                          57     4
  1.1 Nested Loops                                                        57     4
    2.1 Table Access (Full)            EMP             TABLE              37     3


*******************************************************************************************************************************************************

11/25/2008
Got IM/call from Steve Capson and David Capasso on SPOK tickets someting causing white screen.

1. Look at sar and topas and see high CPU % utilization.
2. Run 

---Mike's who_active.sql
--I looked at it a different way. 
  Rather than looking at CPU, I was looking at waits. 
  I've attached --the SQL that I use to see the active queries in the database. 
  What I saw, was a bunch of queries --with the same hash all waiting on latches. 
  Knowing that processes spin on latches, I figured those --were the ones using the CPU. 
  The first time it happened, I also used nmon to identify some spids --and tracked those back to the session through v$process.
--nmon t (top process)



select /*+ leading(s) */ decode(pxs.qcsid, null, s.sid, pxs.qcsid) as QCSID, 
       s.sid, 
       p.spid, 
       substr(decode(s.type, 'USER', s.username, 'BACKGROUND', 'ORA-' ||bg.name, s.username), 1, 15) as username, 
       substr(decode(aa.name, 'UNKNOWN', '--', aa.name ), 1, 15) as command,
       s.status,
       substr(s.osuser, 1, 15) as osuser, 
       substr(s.machine, 1, 30) as machine,
       substr(s.program, 1, 20) as program, 
       substr(s.module, 1, 15) as module,
       substr(s.action, 1, 15) as action,
       s.sql_hash_value,
       sw.event,
       s.lockwait,
       s.row_wait_obj#,
       s.row_wait_row#,
       to_char(s.logon_time, 'YYYY-MM-DD HH24:MI') as logon_time, 
       s.last_call_et,
       sio.block_gets,
       sio.consistent_gets,
       sio.physical_reads,
       sio.block_changes,
       sio.consistent_changes
from v$session s,
     v$process p,
     v$sess_io sio,
     v$px_session pxs,
     v$bgprocess bg,
     audit_actions aa,
     v$session_wait sw
where s.paddr = p.addr
  and s.sid = sio.sid
  and s.saddr = pxs.saddr (+)
  and s.command = aa.action
  and s.paddr = bg.paddr (+)
  and s.status = 'ACTIVE'
  and s.type <> 'BACKGROUND'
  and s.sid = sw.sid
order by sio.consistent_gets, s.username, decode(pxs.qcsid, null, s.sid, pxs.qcsid);


3. See if any latches happens in database

 select SID, USERNAME, machine,status from v$session where sid  
in (select sid from v$session_wait where event='latch free');
select * 
from v$session s where s.last_call_et > 600 and sid 
in (select sid from v$session_wait where event='latch free');

4. Kill session sql

  select 'alter system kill session ''' || sid || ',' || serial# || ''';' 
  from v$session where --username='WKAB10' and sql_hash_value=3651867244;

  or

  --select 'alter system kill session ''' || sid || ',' || serial# || ''';' last_call_et 
--from v$session s where s.last_call_et > 600 and sid 
--in (select sid from v$session_wait where event='latch free');



BASED ON ABOVE BAD QUERY was identified.

Ask developer to provide values, so it could be run to get execution plan


It's reproducible in WKABSTG1 so I did some analysis there and it 
seems that it has to do with that large IN list combined with the use of a bitmap index that is
 on T_PERSON(LAST_NAME).  
I'm not a big fan of bitmap indexes in OLTP systems anyway, so long term I'd like to get rid of that index.
  Short-term, though, I found a fix by telling it not to use that index for this query. 
 When run the version below with the hint to tell it not to use that index, it returns almost instantaneously.
 
Mike
 
SELECT * FROM ( SELECT ROWNUM R, LEAVE_ID, CONFIRMATION_NUMBER,PRODUCT, COMPANY_NAME, EMPLOYEE_ID, 
                       EMP_ID, LAST_NAME, FIRST_NAME, EMP_STATUS_CODE, TERMINATION_DATE 
  FROM (SELECT /*+ no_index(s_person T_PERSON_IDX_002) */ '' AS LEAVE_ID, '' AS CONFIRMATION_NUMBER, '' AS PRODUCT,
                '' AS COMPANY_NAME,S_EMPLOYEE.EMPLOYEE_ID,
                S_EMPLOYEE.EMP_ID, S_PERSON.LAST_NAME, S_PERSON.FIRST_NAME,
                DECODE(S_EMPLOYEE.EMP_STATUS_CODE,'T','Resigned','A','Active','I',
                       'Inactive','L','Leave','R','Retired') AS EMP_STATUS_CODE,
                S_EMPLOYEE.TERMINATION_DATE
           FROM S_EMPLOYEE,
                S_PERSON
          WHERE S_PERSON.PERSON_ID = S_EMPLOYEE.PERSON_ID
            AND GROUP_ID IN ( SELECT GROUP_ID
                                FROM S_GROUP G
                              START WITH GROUP_ID IN ( SELECT S_GE.GROUP_ID
                                                         FROM S_COMPANY_ROLE_MATRIX S_CRM,
                                                              S_GROUP_EMPLOYEE S_GE,
                                                              S_COMPANY_ROLE S_CR
                                                        WHERE S_GE.EMPLOYEE_ID = 155981633
                                                          AND S_GE.COMPANY_ID = (SELECT COMPANY_ID
                                                                                   FROM S_EMPLOYEE
                                                                                  WHERE EMPLOYEE_ID = 155981633 )
                                                          AND S_GE.ROLE_ID = S_CR.FILE_ROLE_CODE
                                                          AND S_CR.COMPANY_ROLE_ID = S_CRM.COMPANY_ROLE_ID
                                                          AND S_CR.PRIVILEGED_ROLE = 'Y'
                                                          AND S_CRM.TEAM_RIGHT_TYPES_ID = 302
                                                      )
                                 AND G.COMPANY_ID = (SELECT COMPANY_ID
                                                       FROM S_EMPLOYEE
                                                      WHERE EMPLOYEE_ID = 155981633 )
                               CONNECT BY PARENT_GROUP_ID = PRIOR GROUP_ID
                            )
            AND LAST_NAME LIKE 'SMIT%' --:B2
            AND FIRST_NAME LIKE 'J%' --:B1
       )
) 
WHERE R >= 1 AND R <= 10



The explain plain option is a theoretical option which just shows what plan +may be + picked up by optimizer to execute the query. 
But this query won't run the query in actual so the actual plan used by the query may very well be different from this one. 

The dbms_xplan.display is nothing but a way to see the output of the explain plan command.
 The result of the explain plan command is stored in a table alled plan-table . To show the output in a good way, the package is used. 

The view V$SQL_PLAN_STATISTICS_ALL would show the actual stats for the query when it was run. 

V$SQL_PLAN_STATISTICS_ALL

select * from V$SQL_PLAN_STATISTICS_ALL where SQL_id = '8k4kamm4ds5yn'

*************Nice outputs for explain plan ****************


Use Windows cmd sqlplus

I set pagesize to 1024 and linesize 1024 and run them out of a Windows command prompt with the screen buffer width set to 1024.  In the e-mail I have to make them Courier New for the font and set the font size to 8 after I copy/paste them in.

system/no734s@DNTMT001.world


EXPLAIN PLAN
  SET STATEMENT_ID = 'st1' FOR
SELECT SUPERVISOR_UID, SUPERVISOR_NAME,SUPERVISOR_ID,LEVEL_CODE,WORK_PHONE,EMAIL,JOB_TITLE,EMPLOYEE_UID  
FROM emp_upper_supervisor_vw  
WHERE EMPLOYEE_UID=2613   ORDER BY LEVEL_CODE;

SET LINESIZE 1024
SET PAGESIZE 1024


SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

Database: DR02

Level 0  Rman Backup with CHECK LOGICAL failed with following errors.


RMAN-00571: ===========================================================
RMAN-00569: =============== ERROR MESSAGE STACK FOLLOWS ===============
RMAN-00571: ===========================================================
RMAN-03002: failure of backup plus archivelog command at 09/06/2009 20:17:19

RMAN-03009: failure of backup command on ORA_SBT_TAPE_1 channel at 09/06/2009 19
:11:16
ORA-19566: exceeded limit of 0 corrupt blocks for file /u36/oracle/DR02/index/drwkab_index_08.dbf

See Note: 336133.1


example to use dbv:


--sqlplus / as sysdba

show parameter blocksize
db_block_size                        integer     4096
exit

dbv file=/u36/oracle/DR02/index/drwkab_index_08.dbf blocksize=4096 


DBVERIFY: Release 11.1.0.7.0 - Production on Tue Sep 8 09:16:05 2009

Copyright (c) 1982, 2007, Oracle.  All rights reserved.

DBVERIFY - Verification starting : FILE = /u36/oracle/DR02/index/drwkab_index_08
.dbf
Block Checking: DBA = 487031951, Block Type = KTB-managed data block
data header at 0x1105ac05c
kdbchk: row locked by non-existent transaction
        table=0   slot=38
        lockid=1   ktbbhitc=2
Page 492687 failed with check code 6101


DBVERIFY - Verification complete

Total Pages Examined         : 768000
Total Pages Processed (Data) : 501015
Total Pages Failing   (Data) : 1
Total Pages Processed (Index): 30931
Total Pages Failing   (Index): 0
Total Pages Processed (Other): 38
Total Pages Processed (Seg)  : 0
Total Pages Failing   (Seg)  : 0
Total Pages Empty            : 236016
Total Pages Marked Corrupt   : 0
Total Pages Influx           : 0
Total Pages Encrypted        : 0
Highest block SCN            : 2175165422 (1914.2175165422)



select file_id from dba_data_files where file_name like '%drwkab_index_08.dbf%'

116

select segment_name, segment_type, owner
       from dba_extents
      where file_id = 116
        and 492687 between block_id
            and block_id + blocks -1;


Select * from dba_free_space where file_id= 116
     and 492687 between block_id and block_id + blocks -1;


Mike's completed this fix based on Metalink Note *************************


=== Procedure ===========
1) Use dbv to confirm the corruption
    dbv file=/u36/oracle/DR02/index/drwkab_index_08.dbf blocksize=4096

   Should show
Block Checking: DBA = 487031951, Block Type = KTB-managed data block   
data header at 0x1104ab05c                                             
kdbchk: row locked by non-existent transaction                         
        table=0   slot=38                                              
        lockid=1   ktbbhitc=2                                          
Page 492687 failed with check code 6101    

2) Get the info on the block
SQL> select dbms_utility.data_block_address_block(487031951) from dual;

DBMS_UTILITY.DATA_BLOCK_ADDRESS_BLOCK(487031951)
------------------------------------------------
                                          492687

SQL> select dbms_utility.data_block_address_file(487031951) from dual;

DBMS_UTILITY.DATA_BLOCK_ADDRESS_FILE(487031951)
-----------------------------------------------
                                            116
3) Find out if the block is allocated or free.  This will only work if it's free.

4) select * from dba_free_space where file_id=116 and 492687 between block_id and block_id+blocks-1;
    --> show show one row.  If so, the block is free.  If not, it's allocated to an object.

5) In SQLPlus do the following.  Note: 492687 is the corrupt block. And drwkab_data is the tablespace with the problem data file.

SQL> create table x (c1 number, c2 varchar2(4000)) tablespace 
SQL> drwkab_data;

Table created.

SQL> CREATE OR REPLACE TRIGGER corrupt_trigger
  2    AFTER INSERT ON x
  3    REFERENCING OLD AS p_old NEW AS new_p
  4    FOR EACH ROW
  5  DECLARE
  6    corrupt EXCEPTION;
  7  BEGIN
  8    IF (dbms_rowid.rowid_block_number(:new_p.rowid)=492687) then
  9       RAISE corrupt;
 10    END IF;
 11  EXCEPTION
 12    WHEN corrupt THEN
 13       RAISE_APPLICATION_ERROR(-20000, 'Corrupt block has been formatted');
 14  END;
 15  /

Trigger created.

6) Check free-space left in  the datafile
    select sum(bytes)/1024/1024 from dba_free_space where file_id=116;

7) Allocate enough space to cover the bad block.
    alter table x allocate extent (DATAFILE '/u36/oracle/DR02/index/drwkab_index_08.dbf' SIZE 1400M);

8) Insert rows into table (this should use the space you allocated to the table).  The trigger will fire when 
   the bad block is overwritten.
SQL> BEGIN
  2  FOR i IN 1..1000000000 LOOP
  3  INSERT INTO x select i, lpad('REFORMAT',3092, 'R') from dual;
  4  commit ;
  5  END LOOP;
  6  END;
  7  /
BEGIN
*
ERROR at line 1:
ORA-20000: Corrupt block has been formatted
ORA-06512: at "SYSTEM.CORRUPT_TRIGGER", line 9
ORA-04088: error during execution of trigger 'SYSTEM.CORRUPT_TRIGGER'
ORA-06512: at line 3

9) Flush the changed blocks out of memory
     alter system checkpoint;

10) Re-check w/ dbv as above.

11) Drop table x



